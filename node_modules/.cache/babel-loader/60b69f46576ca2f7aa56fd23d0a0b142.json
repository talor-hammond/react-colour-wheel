{"ast":null,"code":"import tinycolor from 'tinycolor2'; // TODO: Make this smaller?\n\nexport function produceRgbShades(r, g, b, amount) {\n  var shades = [];\n  var hsl = tinycolor(\"rgb(\".concat(r, \", \").concat(g, \", \").concat(b, \")\")).toHsl();\n\n  for (var i = 9; i > 1; i -= 8 / amount) {\n    // Decrements from 9 - 1; i being what luminosity (hsl.l) is multiplied by.\n    hsl.l = 0.1 * i;\n    shades.push(tinycolor(hsl).toRgb());\n  }\n\n  return shades;\n}\nexport function colourToRgbObj(colour) {\n  // TODO: Note which colours tinycolor() can take; i.e. hex / rgb strings, objects, etc.\n  return tinycolor(colour).toRgb();\n}\nexport function calculateBounds(min, max) {\n  // i.e. min & max pixels away from the center of the canvas.\n  return {\n    inside: function inside(cursorPosFromCenter) {\n      // our relative mouse-position is passed through here to check.\n      return cursorPosFromCenter >= min && cursorPosFromCenter <= max;\n    }\n  };\n}\nexport function convertObjToString(obj) {\n  return tinycolor(obj).toRgbString();\n} // Method is helpful for generating a radius representative of the stroke + taking into account lineWidth.\n\nexport function getEffectiveRadius(trueRadius, lineWidth) {\n  return trueRadius - lineWidth / 2;\n}","map":{"version":3,"sources":["/Users/tay/Desktop/codey/react-colour-wheel/src/utils/utils.js"],"names":["tinycolor","produceRgbShades","r","g","b","amount","shades","hsl","toHsl","i","l","push","toRgb","colourToRgbObj","colour","calculateBounds","min","max","inside","cursorPosFromCenter","convertObjToString","obj","toRgbString","getEffectiveRadius","trueRadius","lineWidth"],"mappings":"AAAA,OAAOA,SAAP,MAAsB,YAAtB,C,CAAmC;;AAEnC,OAAO,SAASC,gBAAT,CAA2BC,CAA3B,EAA8BC,CAA9B,EAAiCC,CAAjC,EAAoCC,MAApC,EAA4C;AACjD,MAAIC,MAAM,GAAG,EAAb;AAEA,MAAMC,GAAG,GAAGP,SAAS,eAAQE,CAAR,eAAcC,CAAd,eAAoBC,CAApB,OAAT,CAAmCI,KAAnC,EAAZ;;AAEA,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,CAApB,EAAuBA,CAAC,IAAI,IAAIJ,MAAhC,EAAwC;AAAE;AACxCE,IAAAA,GAAG,CAACG,CAAJ,GAAQ,MAAMD,CAAd;AACAH,IAAAA,MAAM,CAACK,IAAP,CAAYX,SAAS,CAACO,GAAD,CAAT,CAAeK,KAAf,EAAZ;AACD;;AAED,SAAON,MAAP;AACD;AAED,OAAO,SAASO,cAAT,CAAyBC,MAAzB,EAAiC;AAAE;AACxC,SAAOd,SAAS,CAACc,MAAD,CAAT,CAAkBF,KAAlB,EAAP;AACD;AAED,OAAO,SAASG,eAAT,CAA0BC,GAA1B,EAA+BC,GAA/B,EAAoC;AAAE;AAC3C,SAAO;AACLC,IAAAA,MAAM,EAAE,gBAACC,mBAAD,EAAyB;AAAE;AACjC,aAAOA,mBAAmB,IAAIH,GAAvB,IAA8BG,mBAAmB,IAAIF,GAA5D;AACD;AAHI,GAAP;AAKD;AAED,OAAO,SAASG,kBAAT,CAA6BC,GAA7B,EAAkC;AACvC,SAAOrB,SAAS,CAACqB,GAAD,CAAT,CAAeC,WAAf,EAAP;AACD,C,CAED;;AACA,OAAO,SAASC,kBAAT,CAA6BC,UAA7B,EAAyCC,SAAzC,EAAoD;AACzD,SAAOD,UAAU,GAAGC,SAAS,GAAG,CAAhC;AACD","sourcesContent":["import tinycolor from 'tinycolor2' // TODO: Make this smaller?\n\nexport function produceRgbShades (r, g, b, amount) {\n  let shades = []\n\n  const hsl = tinycolor(`rgb(${r}, ${g}, ${b})`).toHsl()\n\n  for (let i = 9; i > 1; i -= 8 / amount) { // Decrements from 9 - 1; i being what luminosity (hsl.l) is multiplied by.\n    hsl.l = 0.1 * i\n    shades.push(tinycolor(hsl).toRgb())\n  }\n\n  return shades\n}\n\nexport function colourToRgbObj (colour) { // TODO: Note which colours tinycolor() can take; i.e. hex / rgb strings, objects, etc.\n  return tinycolor(colour).toRgb()\n}\n\nexport function calculateBounds (min, max) { // i.e. min & max pixels away from the center of the canvas.\n  return {\n    inside: (cursorPosFromCenter) => { // our relative mouse-position is passed through here to check.\n      return cursorPosFromCenter >= min && cursorPosFromCenter <= max\n    }\n  }\n}\n\nexport function convertObjToString (obj) {\n  return tinycolor(obj).toRgbString()\n}\n\n// Method is helpful for generating a radius representative of the stroke + taking into account lineWidth.\nexport function getEffectiveRadius (trueRadius, lineWidth) {\n  return trueRadius - lineWidth / 2\n}\n"]},"metadata":{},"sourceType":"module"}